# command_actions.py
import subprocess
import keyboard  # pip install keyboard
import os
import webbrowser
import requests
from dotenv import load_dotenv
from PyQt5.QtWidgets import QApplication, QMessageBox, QInputDialog

# Load environment variables
load_dotenv()
NB_STUDIO_API_KEY = os.getenv("NB_STUDIO_API_KEY")
if not NB_STUDIO_API_KEY:
    raise ValueError("NB_STUDIO_API_KEY not found in environment variables. Please set it in your .env file.")

# Nebius API endpoint for chat completions
NEBIUS_API_URL = "https://api.studio.nebius.ai/v1/chat/completions"

# Global dictionaries to store opened process handles
opened_apps = {}
opened_urls = {}

def stop_music():
    keyboard.send("play/pause media")
    print("Toggled media playback (stop).")

def start_music():
    keyboard.send("play/pause media")
    print("Toggled media playback (start).")

def translate_text():
    """
    Capture the screen, perform OCR to extract text, detect its language,
    and if non-English, use Nebius to translate it into English.
    """
    from PyQt5.QtWidgets import QApplication, QMessageBox
    import pyautogui  # pip install pyautogui
    import pytesseract  # pip install pytesseract (requires Tesseract OCR installed)
    from langdetect import detect, DetectorFactory  # pip install langdetect

    DetectorFactory.seed = 0
    parent = QApplication.activeWindow()
    screenshot = pyautogui.screenshot()
    extracted_text = pytesseract.image_to_string(screenshot)
    if not extracted_text.strip():
        QMessageBox.information(parent, "Translation", "No text found on screen.")
        return

    try:
        detected_lang = detect(extracted_text)
        print(f"Detected language: {detected_lang}")
    except Exception as e:
        detected_lang = "unknown"
        print("Error detecting language:", e)

    if detected_lang == "en":
        QMessageBox.information(parent, "Translation", "The screen text appears to be in English.")
        return

    prompt = f"Translate the following text into English: {extracted_text.strip()}"
    headers = {
        "Authorization": f"Bearer {NB_STUDIO_API_KEY}",
        "Content-Type": "application/json"
    }
    data = {
        "model": "meta-llama/Meta-Llama-3.1-70B-Instruct",
        "messages": [{"role": "user", "content": prompt}],
        "temperature": 1,
        "max_tokens": 500
    }
    try:
        response = requests.post(NEBIUS_API_URL, headers=headers, json=data)
        if response.status_code == 200:
            result = response.json()
            translation = result["choices"][0]["message"]["content"]
            QMessageBox.information(parent, "Translation", translation)
        else:
            QMessageBox.warning(parent, "Translation Error", f"API Error: {response.text}")
    except requests.exceptions.RequestException as e:
        QMessageBox.warning(parent, "Translation Error", f"Error calling Nebius API: {e}")

def copy_neural_network_diagram():
    print("Copying neural network diagram from screen... (feature not yet implemented)")

def create_new_file():
    filename = "new_file.py"
    content = "# New Python file generated by Hey Miso\n\nprint('Hello from Hey Miso!')\n"
    try:
        with open(filename, "w") as f:
            f.write(content)
        subprocess.run(["code", filename], check=True)
        print(f"Created and opened {filename} in VS Code.")
    except Exception as e:
        print("Error creating/opening file:", e)

def open_app():
    parent = QApplication.activeWindow()
    app_path, ok = QInputDialog.getText(parent, "Open App", "Enter application path or name:")
    if not ok or not app_path.strip():
        print("No application specified.")
        return
    app_path = app_path.strip()
    try:
        # Use subprocess.Popen to open the app and store its process handle.
        proc = subprocess.Popen(app_path, shell=True)
        opened_apps[app_path] = proc
        print(f"Opened application: {app_path}")
    except Exception as e:
        QMessageBox.warning(parent, "Open App Error", f"Error opening application: {e}")

def close_app():
    parent = QApplication.activeWindow()
    app_name, ok = QInputDialog.getText(parent, "Close App", "Enter application name to close:")
    if not ok or not app_name.strip():
        print("No application specified.")
        return
    app_name = app_name.strip()
    proc = opened_apps.get(app_name)
    if proc:
        proc.terminate()
        proc.wait()
        print(f"Closed application: {app_name}")
        del opened_apps[app_name]
    else:
        QMessageBox.information(parent, "Close App", "Application not found among open apps.")

def open_url():
    parent = QApplication.activeWindow()
    url, ok = QInputDialog.getText(parent, "Open URL", "Enter URL to open:")
    if not ok or not url.strip():
        print("No URL specified.")
        return
    url = url.strip()
    # Fuzzy processing: if url doesn't start with http:// or https://, attempt to complete it
    if not (url.startswith("http://") or url.startswith("https://")):
        url = url.replace(" ", "")
        if "." not in url:
            url += ".com"
        url = "https://www." + url
    try:
        # Attempt to launch with Chrome to obtain a process handle
        proc = subprocess.Popen(["chrome", url], shell=True)
        opened_urls[url] = proc
        print(f"Opened URL: {url}")
    except Exception as e:
        import webbrowser
        webbrowser.open(url)
        print(f"Opened URL using webbrowser: {url}")

def close_url():
    parent = QApplication.activeWindow()
    url, ok = QInputDialog.getText(parent, "Close URL", "Enter URL to close:")
    if not ok or not url.strip():
        print("No URL specified.")
        return
    url = url.strip()
    if not (url.startswith("http://") or url.startswith("https://")):
        url = url.replace(" ", "")
        if "." not in url:
            url += ".com"
        url = "https://www." + url
    proc = opened_urls.get(url)
    if proc:
        proc.terminate()
        proc.wait()
        print(f"Closed URL: {url}")
        del opened_urls[url]
    else:
        QMessageBox.information(parent, "Close URL", "URL process not found.")

# Global dictionaries to store process handles
opened_apps = {}
opened_urls = {}
