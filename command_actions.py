# command_actions.py
import subprocess
import keyboard  # pip install keyboard
import os
import webbrowser
import requests
from dotenv import load_dotenv
from PyQt5.QtWidgets import QApplication, QMessageBox, QInputDialog

# Load environment variables
load_dotenv()
NB_STUDIO_API_KEY = os.getenv("NB_STUDIO_API_KEY")
if not NB_STUDIO_API_KEY:
    raise ValueError("NB_STUDIO_API_KEY not found in environment variables. Please set it in your .env file.")

# Nebius API endpoint for chat completions
NEBIUS_API_URL = "https://api.studio.nebius.ai/v1/chat/completions"

# Global dictionaries to store opened process handles
opened_apps = {}
opened_urls = {}

def stop_music():
    keyboard.send("play/pause media")
    print("Toggled media playback (stop).")

def start_music():
    keyboard.send("play/pause media")
    print("Toggled media playback (start).")

def translate_text():
    """
    Capture the screen, perform OCR to extract text, detect its language,
    and if non-English, use Nebius to translate it into English.
    """
    from PyQt5.QtWidgets import QApplication, QMessageBox
    import pyautogui  # pip install pyautogui
    import pytesseract  # pip install pytesseract (requires Tesseract OCR installed)
    from langdetect import detect, DetectorFactory  # pip install langdetect

    DetectorFactory.seed = 0
    parent = QApplication.activeWindow()
    screenshot = pyautogui.screenshot()
    extracted_text = pytesseract.image_to_string(screenshot)
    if not extracted_text.strip():
        QMessageBox.information(parent, "Translation", "No text found on screen.")
        return

    try:
        detected_lang = detect(extracted_text)
        print(f"Detected language: {detected_lang}")
    except Exception as e:
        detected_lang = "unknown"
        print("Error detecting language:", e)

    if detected_lang == "en":
        QMessageBox.information(parent, "Translation", "The screen text appears to be in English.")
        return

    prompt = f"Translate the following text into English: {extracted_text.strip()}"
    headers = {
        "Authorization": f"Bearer {NB_STUDIO_API_KEY}",
        "Content-Type": "application/json"
    }
    data = {
        "model": "meta-llama/Meta-Llama-3.1-70B-Instruct",
        "messages": [{"role": "user", "content": prompt}],
        "temperature": 1,
        "max_tokens": 500
    }
    try:
        response = requests.post(NEBIUS_API_URL, headers=headers, json=data)
        if response.status_code == 200:
            result = response.json()
            translation = result["choices"][0]["message"]["content"]
            QMessageBox.information(parent, "Translation", translation)
        else:
            QMessageBox.warning(parent, "Translation Error", f"API Error: {response.text}")
    except requests.exceptions.RequestException as e:
        QMessageBox.warning(parent, "Translation Error", f"Error calling Nebius API: {e}")

def copy_neural_network_diagram():
    print("Copying neural network diagram from screen... (feature not yet implemented)")

def create_new_file():
    filename = "new_file.py"
    content = "# New Python file generated by Hey Miso\n\nprint('Hello from Hey Miso!')\n"
    try:
        with open(filename, "w") as f:
            f.write(content)
        subprocess.run(["code", filename], check=True)
        print(f"Created and opened {filename} in VS Code.")
    except Exception as e:
        print("Error creating/opening file:", e)

def open_app(app_name=None):
    """
    Opens an application using the provided app name.
    If no app name is provided, falls back to asking the user.
    """
    if app_name is None or app_name.strip() == "":
        parent = QApplication.activeWindow()
        app_path, ok = QInputDialog.getText(parent, "Open App", "Enter application path or name:")
        if not ok or not app_path.strip():
            print("No application specified.")
            return
        app_name = app_path.strip()
    else:
        app_name = app_name.strip()

    try:
        # Attempt to open the app.
        # (On Windows, if the app is in your PATH or registered, this should work.)
        proc = subprocess.Popen(app_name, shell=True)
        opened_apps[app_name] = proc
        print(f"Opened application: {app_name}")
    except Exception as e:
        print("Error opening application:", e)

def close_app(app_name=None):
    parent = QApplication.activeWindow()
    if app_name is None or app_name.strip() == "":
        app_name, ok = QInputDialog.getText(parent, "Close App", "Enter application name to close:")
        if not ok or not app_name.strip():
            print("No application specified.")
            return
        app_name = app_name.strip()
    else:
        app_name = app_name.strip()
    proc = opened_apps.get(app_name)
    if proc:
        proc.terminate()
        proc.wait()
        print(f"Closed application: {app_name}")
        del opened_apps[app_name]
    else:
        QMessageBox.information(parent, "Close App", "Application not found among open apps.")

def open_url(url_input=None):
    """
    Opens a URL based on the provided string.
    If the string matches a known website (like 'wikipedia' or 'google'),
    it opens the corresponding homepage. Otherwise, it attempts to build a URL.
    """
    if url_input is None or url_input.strip() == "":
        parent = QApplication.activeWindow()
        url, ok = QInputDialog.getText(parent, "Open URL", "Enter URL to open:")
        if not ok or not url.strip():
            print("No URL specified.")
            return
        url_input = url.strip()
    else:
        url_input = url_input.strip()

    # Define a dictionary of known websites.
    known_websites = {
        "google": "https://www.google.com",
        "wikipedia": "https://www.wikipedia.org",
        "youtube": "https://www.youtube.com",
        "facebook": "https://www.facebook.com",
        "twitter": "https://www.twitter.com",
        "reddit": "https://www.reddit.com",
        # Add more as needed.
    }

    lower_input = url_input.lower()
    final_url = None
    for key, website in known_websites.items():
        if key in lower_input:
            final_url = website
            break
    if final_url is None:
        # If no match was found, try to build a URL.
        final_url = url_input.replace(" ", "")
        if not (final_url.startswith("http://") or final_url.startswith("https://")):
            if "." not in final_url:
                final_url += ".com"
            final_url = "https://www." + final_url

    try:
        webbrowser.open(final_url)
        print(f"Opened URL: {final_url}")
    except Exception as e:
        print(f"Error opening URL: {e}")

def close_url(url_input=None):
    parent = QApplication.activeWindow()
    if url_input is None or url_input.strip() == "":
        url, ok = QInputDialog.getText(parent, "Close URL", "Enter URL to close:")
        if not ok or not url.strip():
            print("No URL specified.")
            return
        url_input = url.strip()
    else:
        url_input = url_input.strip()

    # Process the URL similar to open_url.
    if not (url_input.startswith("http://") or url_input.startswith("https://")):
        url_input = url_input.replace(" ", "")
        if "." not in url_input:
            url_input += ".com"
        url_input = "https://www." + url_input
    proc = opened_urls.get(url_input)
    if proc:
        proc.terminate()
        proc.wait()
        print(f"Closed URL: {url_input}")
        del opened_urls[url_input]
    else:
        QMessageBox.information(parent, "Close URL", "URL process not found.")

# (Re)initialize the dictionaries for process handles.
opened_apps = {}
opened_urls = {}
